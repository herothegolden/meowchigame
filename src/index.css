@import url('https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap');

:root {
  /* Golden Patisserie Palette */
  --bg: #fdf9f4;
  --card: #ffffff;
  --surface: #f8f4ed;
  --text: #4c3f38;
  --muted: #a18f85;
  --accent: #d4af37;
  --accent2: #f4d03f;
  --accent-text: #ffffff;
  --border: rgba(76, 63, 56, 0.1);

  --line: rgba(76, 63, 56, 0.1); /* For borders and dividers */
  --accent-light: rgba(212, 175, 55, 0.1); /* For hover effects */
  /* Splash controls */
  --bar-top: 60%;
  --bar-width: 230px;
}

*{box-sizing:border-box}
html,body,#root{height:100%}
body{
  margin:0;
  font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  font-weight: 400;
}

/* app shell */
.shell{
  max-width: 520px;
  margin: 0 auto;
  min-height: calc(var(--vh,1vh)*100);
  display:flex;
  flex-direction:column;
  background: var(--bg);
}

/* header - elegant and minimal - FIXED HEADER */
.header{
  position: fixed;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100%;
  max-width: 520px;
  padding: 16px 20px 12px;
  background: var(--bg);
  border-bottom: 1px solid var(--line);
  z-index: 1000;
}

.header-content{
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.brand{
  display: flex;
  align-items: center;
  gap: 12px;
}

.logo{
  font-size: 24px;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  overflow: hidden;
  display: grid;
  place-items: center;
  background: linear-gradient(135deg, #fef9ea, #f8f3e0);
}

.logo img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.brand-text{
  font-weight: 800;
  font-size: 20px;
  color: var(--text);
  letter-spacing: -0.3px;
}

.back-btn{
  appearance: none;
  border: none;
  background: var(--surface);
  color: var(--text);
  width: 40px;
  height: 40px;
  border-radius: 12px;
  display: grid;
  place-items: center;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid var(--border);
}

.back-btn:hover{
  background: var(--accent-light);
  border-color: var(--accent);
}

.back-icon{
  font-size: 18px;
  font-weight: bold;
}

.coins-display{
  display: flex;
  align-items: center;
  gap: 8px;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: #ffffff;
  padding: 10px 16px;
  border-radius: 20px;
  font-weight: 700;
  font-size: 14px;
}

.coins-icon{
  font-size: 16px;
}

.coins-amount{
  letter-spacing: -0.1px;
}

/* content area */
.content{
  flex: 1;
  padding: 80px 0 80px 0; /* TOP PADDING FOR FIXED HEADER + Bottom padding for nav */
  overflow-y: auto;
}

/* sections & lists */
.section{
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 20px;
  padding: 24px;
  margin: 16px 20px;
}

.title{
  font-weight: 800;
  margin-bottom: 16px;
  font-size: 20px;
  color: var(--text);
  letter-spacing: -0.2px;
}

.row{
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 0;
  border-bottom: 1px solid var(--line);
}

.row:last-child{
  border-bottom: none;
}

.list{
  display: grid;
}

.grid-gap{
  gap: 12px;
}

.grid-gap-6{
  gap: 8px;
}

.muted{
  color: var(--muted);
}

.small{
  font-size: 13px;
}

.pill{
  background: var(--surface);
  border: 1px solid var(--border);
  padding: 10px 16px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 500;
}

.ellipsis{
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* buttons & tabs */
.btn{
  appearance: none;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px 18px;
  font-weight: 600;
  color: var(--text);
  background: var(--card);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
}

.btn:hover{
  background: var(--surface);
  border-color: var(--accent);
  transform: translateY(-1px);
}

.btn.primary{
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  border: none;
  color: #ffffff;
}

.btn.primary:hover{
}

.btn:disabled{
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.tabs{
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}

.tab{
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--muted);
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 13px;
  cursor: pointer;
  user-select: none;
  transition: all 0.2s ease;
  font-weight: 500;
}

.tab.active{
  background: var(--accent);
  color: #ffffff;
  border-color: var(--accent);
}

/* ===== Bottom Navigation ===== */
.bottom-nav{
  position: fixed;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 100%;
  max-width: 520px;
  background: var(--card);
  border-top: 1px solid var(--line);
  z-index: 1000;
}

.nav-container{
  display: flex;
  align-items: center;
  justify-content: space-around;
  padding: 12px 8px 20px;
  position: relative;
}

.nav-item{
  appearance: none;
  border: none;
  background: none;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 8px 12px;
  border-radius: 12px;
  transition: all 0.2s ease;
  min-width: 60px;
  position: relative;
}

/* NAV DIVIDERS */
.nav-item:not(:last-child)::after {
  content: '';
  position: absolute;
  right: -1px;
  top: 20%;
  height: 60%;
  width: 1px;
  background: var(--line);
}

.nav-item:hover{
  background: var(--accent-light);
}

.nav-item.active{
  background: var(--accent-light);
}

.nav-item.active .nav-icon{
  transform: scale(1.1);
}

.nav-item.active .nav-label{
  color: var(--accent);
  font-weight: 700;
}

.nav-icon{
  font-size: 20px;
  transition: transform 0.2s ease;
}

.nav-label{
  font-size: 11px;
  color: var(--muted);
  font-weight: 600;
  transition: all 0.2s ease;
}

/* ===== Splash (elegant theme) ===== */
.splash{
  position: fixed;
  inset: 0;
  z-index: 9999;
  height: calc(var(--vh, 1vh) * 100);
  background: url("/splash.jpg") center center / cover no-repeat;
  background-color: var(--bg);
  display: block;
  opacity: 1;
  transition: opacity 0.35s ease;
}

.splash.hide{
  opacity: 0;
  pointer-events: none;
}

.splash.show{
  opacity: 1;
}

.splash-bar-anchored{
  position: absolute;
  left: 50%;
  top: var(--bar-top);
  transform: translate(-50%, -50%);
  width: var(--bar-width);
  text-align: center;
}

.splash-progress{
  width: 100%;
  height: 8px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.2);
  overflow: hidden;
  /* removed backdrop-filter: blur(4px); */
}

.splash-progress__bar{
  width: 0;
  height: 100%;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  animation: splashbar 2.4s ease forwards; /* NO INFINITE - runs once then stops */
}

@keyframes splashbar{
  to { width: 100%; } /* Fills once then stops */
}

.splash-caption{
  margin-top: 12px;
  width: 100%;
  color: var(--text);
  font-weight: 800;
  font-size: clamp(14px, 4.2vw, 18px);
  letter-spacing: 0.3px;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  white-space: nowrap;
}

/* ===== Board / GameView (FAST ANIMATIONS) ===== */
.section.board-wrap{
  position: relative;
  margin: 12px 16px;
}

.board{
  position: relative;
  margin: 16px auto 12px;
  background: var(--card);
  border-radius: 16px;
  border: 1px solid var(--line);
  overflow: hidden;
  overscroll-behavior: contain;
}

.gridlines{
  position: absolute;
  inset: 0;
  opacity: 0.12;
  pointer-events: none;
}

.tile{
  position: absolute;
  display: grid;
  place-items: center;
  user-select: none;
  touch-action: none;
  border-radius: 12px;
  overflow: hidden;
  transition:
    left 0.15s cubic-bezier(0.2, 0.8, 0.2, 1),
    top 0.15s cubic-bezier(0.2, 0.8, 0.2, 1),
    transform 0.12s cubic-bezier(0.2, 0.8, 0.2, 1),
    opacity 0.12s linear;
  background: var(--surface);
  border: 1px solid var(--border);
  will-change: left, top, transform, opacity;
}

.tile.sel{
  outline: 3px solid var(--accent);
}

/* FIXED: hint pulse - 2 cycles then stop */
.tile.hint .tile-emoji{
  animation: simple-hint-pulse 1.2s ease-in-out; /* replaced hint-pulse */
}

@keyframes hint-pulse{
  0%{ transform: scale(1); }
  25%{ transform: scale(1.08); }  /* First pulse */
  50%{ transform: scale(1); }
  75%{ transform: scale(1.08); }  /* Second pulse */
  100%{ transform: scale(1); }    /* Then stops completely */
}

/* press/grab feel */
.tile.grab .tile-emoji{
  transform: scale(0.96) translateZ(0); /* replaced drop-shadow with translateZ(0) */
  /* removed filter: drop-shadow(...) */
}

/* invalid swap nudge */
.tile.shake{
  animation: shakeH 0.12s ease both;
}

@keyframes shakeH{
  0%{ transform: translateX(0); }
  25%{ transform: translateX(-4px); }
  50%{ transform: translateX(4px); }
  75%{ transform: translateX(-2px); }
  100%{ transform: translateX(0); }
}

/* new spawn drop-in */
.tile.drop-in{
  animation: drop 0.18s cubic-bezier(0.2, 0.8, 0.2, 1);
}

@keyframes drop{
  from{ transform: translateY(-14px); opacity: 0; }
  to{ transform: translateY(0); opacity: 1; }
}

/* ========== FAST BLASTING ANIMATIONS (simplified) ========== */

.tile.blasting {
  animation: simple-blast 0.2s ease forwards; /* replaced mega-pop */
  background: var(--accent2);                 /* simplified background */
  border-radius: 50%;
  z-index: 10 !important;
  transform: translateZ(0);
}

/* simplified inner emoji during blast */
.tile.blasting .tile-emoji {
  transform: scale(1.1) translateZ(0);
  /* removed filter and text-shadow and emoji-glow animation */
}

/* Particle animations - short duration */
@keyframes fly {
  0% { 
    transform: translate(0, 0) scale(1) rotate(0deg); 
    opacity: 1; 
  }
  100% { 
    transform: translate(var(--tx), var(--ty)) scale(0.2) rotate(360deg); 
    opacity: 0; 
  }
}

@keyframes fly-bounce {
  0% { 
    transform: translate(0, 0) scale(1); 
    opacity: 1; 
  }
  40% { 
    transform: translate(calc(var(--tx) * 0.4), calc(var(--ty) * 0.2)) scale(1.1); 
    opacity: 1; 
  }
  100% { 
    transform: translate(var(--tx), var(--ty)) scale(0.1); 
    opacity: 0; 
  }
}

@keyframes fly-spiral {
  0% { 
    transform: translate(0, 0) scale(1) rotate(0deg); 
    opacity: 1; 
  }
  50% { 
    transform: translate(calc(var(--tx) * 0.6), calc(var(--ty) * 0.3)) scale(0.8) rotate(180deg); 
    opacity: 0.8; 
  }
  100% { 
    transform: translate(var(--tx), var(--ty)) scale(0.1) rotate(360deg); 
    opacity: 0; 
  }
}

/* Explosion effects - short duration */
@keyframes explosion-flash {
  0% { 
    transform: scale(0); 
    opacity: 0.8; 
  }
  50% { 
    transform: scale(1); 
    opacity: 0.4; 
  }
  100% { 
    transform: scale(1.5); 
    opacity: 0; 
  }
}

@keyframes shockwave {
  0% { 
    width: 0; 
    height: 0; 
    margin-left: 0; 
    margin-top: 0; 
    opacity: 0.8; 
    border-width: 2px;
  }
  100% { 
    width: 120px; 
    height: 120px; 
    margin-left: -60px; 
    margin-top: -60px; 
    opacity: 0; 
    border-width: 1px;
  }
}

.enhanced-spark {
  will-change: transform, opacity;
  pointer-events: none;
}

/* faster easing while swapping */
.tile.swapping{
  transition:
    left 0.12s cubic-bezier(0.3, 0.9, 0.1, 1),
    top 0.12s cubic-bezier(0.3, 0.9, 0.1, 1),
    transform 0.12s cubic-bezier(0.3, 0.9, 0.1, 1),
    opacity 0.12s linear;
}

/* REPLACED: expensive emoji drop-shadow */
.tile .tile-emoji{
  line-height: 1;
  transform: translateZ(0);
  will-change: transform;
}

/* FIXED: COMBO CELEBRATION OVER STATS ROW */
.combo-celebration {
  position: absolute;
  top: 40px; /* Over the Score/Moves/Combo row */
  left: 50%;
  transform: translateX(-50%);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 0.5em 0.9em;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: #fff;
  border: 2px solid #fff;
  border-radius: 16px;
  animation: combo-explosion 1.5s ease-in-out forwards;
  text-shadow: 
    0 0 8px rgba(255, 255, 255, 0.9),
    0 1px 1px rgba(0,0,0,0.6);
  z-index: 1000;
  pointer-events: none;
  white-space: nowrap; /* stay on one line */
  transform-origin: center center;
  width: auto;
  max-width: min(92vw, 680px); /* keep within viewport */
  box-sizing: border-box;
  font-weight: 700;
  font-size: clamp(14px, 2.8vw, 22px); /* auto-resize across screens */
}

/* Explosion effect above combo text */
.combo-celebration::before {
  content: 'ðŸ’¥âœ¨ðŸŽ‰ðŸ’¥';
  position: absolute;
  top: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 32px;
  animation: explosion-burst 1.5s ease-out forwards;
  z-index: 1001;
}

@keyframes combo-explosion {
  0% { transform: translateX(-50%) scale(0.6) rotate(-5deg); opacity: 0; filter: blur(4px); }
  15% { transform: translateX(-50%) scale(1.3) rotate(3deg); opacity: 1; filter: blur(0px); }
  30% { transform: translateX(-50%) scale(1.1) rotate(-1deg); }
  85% { transform: translateX(-50%) scale(1) rotate(0deg); opacity: 1; filter: blur(0px); }
  100% { transform: translateX(-50%) scale(0.9) rotate(0deg); opacity: 0; filter: blur(2px); }
}

@keyframes explosion-burst {
  0% {
    transform: translateX(-50%) scale(0.5) rotate(0deg);
    opacity: 0;
  }
  20% {
    transform: translateX(-50%) scale(1.5) rotate(180deg);
    opacity: 1;
  }
  70% {
    transform: translateX(-50%) scale(1.2) rotate(360deg);
    opacity: 0.8;
  }
  100% {
    transform: translateX(-50%) scale(2.0) rotate(540deg);
    opacity: 0;
  }
}

/* OLD combo style - REMOVED (was positioned in board center) */
.combo {
  /* This class is no longer used - replaced by combo-celebration */
  display: none;
}

/* pause overlay */
.pause-overlay{
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  background: rgba(255, 255, 255, 0.95);
  /* removed backdrop-filter: saturate(120%) blur(8px); */
}

/* controls under board */
.controls{
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
  padding: 0 4px;
}

.controls .btn{
  padding: 10px 14px;
  font-size: 13px;
}

.controls-size{
  opacity: 0.7;
  font-size: 12px;
  color: var(--muted);
  margin-left: auto;
}

/* poof particles - short duration */
.spark{
  position: absolute;
  transform-origin: var(--cx) var(--cy);
  animation: fly var(--dur, 0.4s) ease-out forwards;
}

/* ===== Leaderboard Styles ===== */
.leaderboard-header {
  margin-bottom: 20px;
}

.title-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.tashkent-time {
  display: flex;
  align-items: center;
  gap: 6px;
  background: var(--surface);
  padding: 6px 12px;
  border-radius: 16px;
  border: 1px solid var(--border);
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
}

.time-icon {
  font-size: 14px;
}

.profile-notice {
  display: flex;
  align-items: center;
  gap: 8px;
  background: var(--accent-light);
  border: 1px solid var(--accent);
  padding: 12px 16px;
  border-radius: 16px;
  font-size: 14px;
  color: var(--accent);
  font-weight: 600;
}

.notice-icon {
  font-size: 16px;
}

.filters {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  padding: 12px 0;
  border-bottom: 1px solid var(--line);
}

.country-filter {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
  transition: all 0.2s ease;
}

.country-filter:hover .checkbox-custom {
  border-color: var(--accent);
  background: var(--accent-light);
}

.country-filter input[type="checkbox"] {
  display: none;
}

.checkbox-custom {
  width: 20px;
  height: 20px;
  border: 2px solid var(--border);
  border-radius: 6px;
  background: var(--card);
  position: relative;
  transition: all 0.2s ease;
}

.country-filter input:checked + .checkbox-custom {
  background: var(--accent);
  border-color: var(--accent);
}

.country-filter input:checked + .checkbox-custom::after {
  content: 'âœ“';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 12px;
  font-weight: bold;
}

.country-filter input:disabled + .checkbox-custom {
  opacity: 0.3;
  cursor: not-allowed;
}

.filter-text {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
}

.filter-info {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

.filter-description {
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
  text-align: right;
}

.last-updated {
  font-size: 12px;
  color: var(--muted);
  font-weight: 500;
}

.retry-info {
  font-size: 12px;
  color: var(--accent);
  margin-top: 8px;
  font-weight: 600;
}

.error-details {
  margin-top: 16px;
  text-align: center;
}

.empty-hint {
  margin-top: 12px;
  text-align: center;
}

.empty-hint .small {
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.debug-info {
  margin-top: 24px;
  opacity: 0.7;
}

.debug-info details {
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px;
}

.debug-info summary {
  cursor: pointer;
  font-size: 12px;
  font-weight: 600;
  color: var(--muted);
  padding: 4px;
}

.debug-info summary:hover {
  color: var(--accent);
}

/* Loading and Error States */
.loading-state, .error-state {
  text-align: center;
  padding: 40px 20px;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.loading-icon, .error-icon, .empty-icon {
  font-size: 48px;
  margin-bottom: 12px;
  opacity: 0.8;
}

.loading-text, .error-text, .empty-text {
  font-size: 16px;
  color: var(--text);
  font-weight: 600;
  margin-bottom: 8px;
}

.error-state .btn {
  margin-top: 16px;
}

/* Leaderboard List */
.leaderboard-list {
  display: grid;
  gap: 8px;
}

.leaderboard-item {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px;
  transition: all 0.2s ease;
}

.leaderboard-item:hover {
  background: var(--card);
  transform: translateY(-1px);
}

/* Enhanced current user highlighting */
.leaderboard-item.current-user {
  background: linear-gradient(135deg, var(--accent-light), rgba(244, 208, 63, 0.05));
  border-color: var(--accent);
}

.leaderboard-item.current-user .player-name {
  font-weight: 700;
}

.leaderboard-item.current-user .player-score {
  font-weight: 900;
  color: var(--accent);
}

/* Rank display improvements */
.rank-display {
  font-size: 20px;
  font-weight: 800;
  min-width: 55px;
  text-align: center;
  color: var(--text);
  letter-spacing: -0.5px;
}

/* Medal styling */
.leaderboard-item:nth-child(1) .rank-display,
.leaderboard-item:nth-child(2) .rank-display,
.leaderboard-item:nth-child(3) .rank-display {
  font-size: 28px;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.leaderboard-item:nth-child(1) .rank-display {
  color: #FFD700;
}

.leaderboard-item:nth-child(2) .rank-display {
  color: #C0C0C0;
}

.leaderboard-item:nth-child(3) .rank-display {
  color: #CD7F32;
}

.player-info {
  flex: 1;
  min-width: 0;
}

.player-name {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 4px;
}

/* Improve country flag display */
.country-flag {
  font-size: 18px;
  flex-shrink: 0;
  margin-right: 2px;
}

.name {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.player-stats {
  font-size: 12px;
  color: var(--muted);
  font-weight: 500;
  line-height: 1.3;
}

.player-score {
  font-size: 20px;
  font-weight: 800;
  color: var(--accent);
  text-align: right;
  letter-spacing: -0.3px;
}

/* Better empty state */
.empty-state {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 40px 20px;
  text-align: center;
}

.empty-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.8;
}

.empty-text {
  font-size: 16px;
  color: var(--text);
  font-weight: 600;
  margin-bottom: 8px;
}

/* User Rank Section */
.user-rank-section {
  margin-top: 32px;
}

/* Section divider improvements */
.section-divider {
  text-align: center;
  margin: 32px 0 20px 0;
  position: relative;
}

.section-divider::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--line), transparent);
  z-index: 1;
}

.divider-text {
  background: var(--bg);
  padding: 0 16px;
  font-size: 13px;
  font-weight: 700;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  position: relative;
  z-index: 2;
}

/* ===== Profile Modal Styles ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  /* removed backdrop-filter: blur(4px); */
  display: grid;
  place-items: center;
  z-index: 10000;
  padding: 20px;
}

.modal-content {
  background: var(--card);
  border-radius: 24px;
  width: 100%;
  max-width: 480px;
  max-height: 90vh;
  overflow-y: auto;
  border: 1px solid var(--line);
}

.profile-modal {
  animation: modal-enter 0.3s ease-out;
}

@keyframes modal-enter {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(20px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.modal-header {
  padding: 32px 32px 20px;
  text-align: center;
  border-bottom: 1px solid var(--line);
}

.modal-title {
  font-size: 24px;
  font-weight: 800;
  color: var(--text);
  margin: 0 0 8px 0;
  letter-spacing: -0.2px;
}

.modal-subtitle {
  font-size: 14px;
  color: var(--muted);
  margin: 0;
  font-weight: 500;
}

.modal-body {
  padding: 24px 32px;
}

.modal-footer {
  padding: 20px 32px 32px;
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  border-top: 1px solid var(--line);
}

.error-message {
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(231, 76, 60, 0.1);
  color: #e74c3c;
  padding: 12px 16px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 20px;
  border: 1px solid rgba(231, 76, 60, 0.2);
}

.error-icon {
  font-size: 16px;
}

.detection-notice {
  display: flex;
  align-items: center;
  gap: 8px;
  background: var(--accent-light);
  color: var(--accent);
  padding: 12px 16px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 20px;
  border: 1px solid rgba(212, 175, 55, 0.3);
}

.detection-icon {
  font-size: 16px;
}

/* Form Styles */
.form-group {
  margin-bottom: 24px;
}

.form-label {
  display: block;
  font-size: 14px;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 8px;
}

.form-input {
  width: 100%;
  padding: 12px 16px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--surface);
  color: var(--text);
  font-size: 16px;
  transition: all 0.2s ease;
}

.form-input:focus {
  outline: none;
  border-color: var(--accent);
}

.form-hint {
  font-size: 12px;
  color: var(--muted);
  margin-top: 6px;
  font-weight: 500;
}

/* Country Selector */
.country-selector {
  position: relative;
}

.country-button {
  width: 100%;
  padding: 12px 16px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--surface);
  color: var(--text);
  font-size: 16px;
  text-align: left;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.country-button:hover {
  border-color: var(--accent);
}

.country-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.selected-country {
  display: flex;
  align-items: center;
  gap: 12px;
}

.country-flag-large {
  font-size: 24px;
}

.country-name {
  font-weight: 600;
}

.placeholder {
  color: var(--muted);
}

.dropdown-arrow {
  color: var(--muted);
  font-size: 12px;
  transition: transform 0.2s ease;
}

.country-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  z-index: 1000;
  margin-top: 4px;
  overflow: hidden;
}

.country-search {
  padding: 12px;
  border-bottom: 1px solid var(--line);
}

.search-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  background: var(--surface);
  color: var(--text);
  font-size: 14px;
}

.search-input:focus {
  outline: none;
  border-color: var(--accent);
}

.country-list {
  max-height: 200px;
  overflow-y: auto;
}

.country-option {
  width: 100%;
  padding: 12px 16px;
  border: none;
  background: none;
  color: var(--text);
  text-align: left;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 12px;
  transition: background 0.2s ease;
}

.country-option:hover {
  background: var(--surface);
}

.country-flag-small {
  font-size: 20px;
  flex-shrink: 0;
}

.loading-spinner {
  display: inline-block;
}

/* Game Over Profile Prompt */
.profile-prompt {
  text-align: center;
  margin-top: 16px;
  padding: 16px;
  background: var(--accent-light);
  border-radius: 12px;
  border: 1px solid rgba(212, 175, 55, 0.3);
}

/* ===== Avatar Selection Grid Styles ===== */
.avatar-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
  margin-top: 8px;
}

.avatar-option {
  appearance: none;
  border: 2px solid var(--border);
  border-radius: 16px;
  padding: 8px;
  background: var(--surface);
  cursor: pointer;
  transition: all 0.2s ease;
  aspect-ratio: 1;
  display: grid;
  place-items: center;
  overflow: hidden;
  position: relative;
}

.avatar-option:hover {
  border-color: var(--accent);
  background: var(--accent-light);
  transform: scale(1.05);
}

.avatar-option.selected {
  border-color: var(--accent);
  background: var(--accent-light);
  transform: scale(1.08);
}

.avatar-option.selected::after {
  content: 'âœ“';
  position: absolute;
  top: 4px;
  right: 4px;
  width: 20px;
  height: 20px;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  display: grid;
  place-items: center;
  font-size: 12px;
  font-weight: bold;
}

.avatar-option img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 8px;
}

/* reduced motion - Remove all animations for accessibility */
@media (prefers-reduced-motion: reduce){
  .tile, .tile.swapping, .tile.drop-in, .tile.blasting,
  .splash-progress__bar, .combo-celebration, .tile.hint .tile-emoji{
    transition: none !important;
    animation: none !important;
  }
  .spark{
    animation: none !important;
    opacity: 0;
  }
}

/* Mobile responsiveness */
@media (max-width: 480px) {
  .header{
    padding: 12px 16px 8px;
  }
  
  .section{
    margin: 12px 16px;
    padding: 20px;
  }
  
  .nav-container{
    padding: 10px 4px 16px;
  }
  
  .nav-item{
    min-width: 50px;
    padding: 6px 8px;
  }
  
  .nav-icon{
    font-size: 18px;
  }
  
  .nav-label{
    font-size: 10px;
  }

  .modal-content {
    margin: 20px;
    max-width: calc(100vw - 40px);
  }
  
  .modal-header, .modal-body, .modal-footer {
    padding-left: 20px;
    padding-right: 20px;
  }
  
  .modal-footer {
    flex-direction: column;
  }
  
  .modal-footer .btn {
    width: 100%;
  }
  
  .title-row {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }
  
  .filters {
    flex-direction: column;
    align-items: stretch;
    gap: 12px;
  }
  
  .filter-info {
    align-items: flex-start;
  }
  
  .filter-description {
    text-align: left;
    font-size: 11px;
  }
  
  .last-updated {
    font-size: 11px;
  }
  
  .leaderboard-item {
    padding: 12px;
    gap: 12px;
  }
  
  .leaderboard-item .player-stats {
    font-size: 11px;
  }
  
  .rank-display {
    font-size: 18px;
    min-width: 45px;
  }
  
  .player-score {
    font-size: 14px;
  }
  
  /* Mobile combo celebration adjustments */
  .combo-celebration {
    font-size: 20px; /* Smaller on mobile */
    padding: 12px;
    border-radius: 16px;
  }
  
  .combo-celebration::before {
    font-size: 24px; /* Smaller explosion on mobile */
    top: -15px;
  }

  /* Avatar grid mobile adjustments */
  .avatar-grid {
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
  }
  
  .avatar-option {
    padding: 6px;
  }
  
  .avatar-option.selected::after {
    width: 18px;
    height: 18px;
    font-size: 11px;
  }
}

/* =========================
   Simplified animations - GPU accelerated (Step 2)
   ========================= */
@keyframes simple-blast {
  0% { 
    transform: scale(1) translateZ(0); 
    opacity: 1; 
  }
  50% { 
    transform: scale(1.4) translateZ(0); 
    opacity: 0.8; 
  }
  100% { 
    transform: scale(2.0) translateZ(0); 
    opacity: 0; 
  }
}

@keyframes simple-hint-pulse {
  0%, 100% { transform: scale(1) translateZ(0); }
  50% { transform: scale(1.1) translateZ(0); }
}

.blast-simple {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 20px;
  pointer-events: none;
  animation: simple-blast-icon 0.2s ease forwards;
}

@keyframes simple-blast-icon {
  0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
}

/* =================================== */
/* ===== PHASE 1 IMPROVEMENTS ====== */
/* =================================== */

/* Step 4: Skeleton Loading Styles */
.skeleton {
  background: linear-gradient(90deg, var(--surface) 25%, var(--card) 50%, var(--surface) 75%);
  background-size: 200% 100%;
  animation: skeleton-loading 1.8s infinite ease-in-out;
  border-radius: 8px;
}

.skeleton-text {
  background-color: var(--surface); /* Fallback for the gradient */
}

@keyframes skeleton-loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* Step 3: Non-Scrolling Game View Container */
.game-view-container {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: 16px;
  align-items: center; /* ðŸ‘ˆ ADD THIS LINE TO CENTER EVERYTHING */
}

.game-view-container .board-wrap {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
}

.game-view-container .board {
  flex-grow: 1;
  flex-shrink: 1;
  min-height: 0;
}

.game-view-container .timer-display,
.game-view-container .row,
.game-view-container .controls,
.game-view-container .progress {
  flex-grow: 0;
  flex-shrink: 0;
}

/* Step 5: UI Juice for Buttons */
.btn:active {
  transform: translateY(-1px) scale(0.98);
  filter: brightness(0.95);
}

/* =================================== */
/* ===== UI/UX FINISHING TOUCHES ===== */
/* =================================== */

/* Seamless Screen Transitions */
.content {
  animation: fadeIn 0.4s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Coin Counter "Pop" Animation */
.coins-display.pop {
  animation: pop-animation 0.5s ease;
}

@keyframes pop-animation {
  0% { transform: scale(1); }
  50% { transform: scale(1.15); }
  100% { transform: scale(1); }
}

/* In-Game Visual Combo Meter */
.combo-meter-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  font-size: 14px;
  text-align: center;
}

.combo-meter-bar {
  width: 80px;
  height: 8px;
  background-color: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}

.combo-meter-fill {
  height: 100%;
  background: linear-gradient(90deg, #f6d365 0%, #fda085 100%);
  transition: width 0.2s ease-out;
  box-shadow: 0 0 8px rgba(253, 160, 133, 0.5);
}

/* Centralized styles moved from Squads.jsx */
.squad-info-card {
  background: var(--surface);
  border-radius: 16px;
  padding: 20px;
  border: 1px solid var(--border);
}

.squad-header { display: flex; align-items: center; gap: 16px; margin-bottom: 20px; }
.squad-icon { font-size: 32px; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background: var(--card); border-radius: 12px; }
.squad-name { font-size: 20px; font-weight: 700; margin: 0 0 4px 0; color: var(--text); }
.squad-stats { font-size: 14px; color: var(--muted); margin: 0; }
.creator-badge { font-size: 12px; color: var(--accent); font-weight: 600; margin: 4px 0 0; }
.squad-actions { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
.invite-code-section { background: var(--card); border-radius: 12px; padding: 16px; border: 1px solid var(--border); }
.invite-code-display { display: flex; align-items: center; gap: 12px; }
.invite-code { font-family: monospace; font-size: 18px; font-weight: 700; color: var(--accent); background: var(--surface); padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border); flex: 1; text-align: center; }
.copy-btn { padding: 8px 16px; font-size: 12px; }
.members-section { margin-top: 20px; }
.members-title { font-size: 16px; font-weight: 700; margin: 0 0 12px 0; color: var(--text); }
.members-list { display: flex; flex-direction: column; gap: 8px; }
.member-item { display: flex; align-items: center; gap: 12px; padding: 8px; background: var(--card); border-radius: 8px; border: 1px solid var(--border); }
.member-rank { font-weight: 800; color: var(--accent); width: 30px; text-align: center; font-size: 14px; }
.member-info { flex: 1; }
.member-name { display: flex; align-items: center; gap: 8px; font-weight: 600; color: var(--text); margin-bottom: 2px; }
.country-flag { font-size: 16px; }
.leader-badge { font-size: 10px; background: var(--accent); color: white; padding: 2px 6px; border-radius: 4px; text-transform: uppercase; font-weight: 700; }
.member-stats { font-size: 12px; color: var(--muted); }
.kick-btn { background: #e74c3c; color: white; border: none; padding: 6px 12px; font-size: 12px; border-radius: 6px; min-width: 50px; }
.member-avatar { width: 40px; height: 40px; border-radius: 12px; overflow: hidden; flex-shrink: 0; background: var(--surface); }
.member-avatar img { width: 100%; height: 100%; object-fit: cover; }

/* =================================== */
/* ===== PHASE 2: STREAK STYLES ====== */
/* =================================== */

.streak-tracker {
  margin-top: 24px;
  margin-bottom: 32px;
  padding: 20px;
  background-color: var(--surface);
  border-radius: 16px;
  border: 1px solid var(--border);
}

.streak-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--text);
  margin: 0 0 16px 0;
  text-align: center;
}

.streak-days {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 8px;
}

.streak-day {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  padding: 8px 4px;
  border-radius: 12px;
  background-color: var(--card);
  border: 1px solid var(--border);
  opacity: 0.6;
  transition: all 0.3s ease;
}

.streak-day.active {
  opacity: 1;
  border-color: var(--accent);
  background-color: var(--accent-light);
  transform: scale(1.05);
}

.day-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--muted);
}

.streak-day.active .day-label {
  color: var(--accent);
}

.day-reward {
  font-size: 13px;
  font-weight: 700;
  color: var(--text);
}

.streak-day:last-child .day-reward {
  font-size: 18px;
}

/* =================================== */
/* ===== POWERUP TRAY STYLES (NEW) ===== */
/* =================================== */

.powerup-tray {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-top: 16px;
}

.powerup-btn {
  appearance: none;
  border: 2px solid var(--border);
  background: var(--surface);
  width: 60px;
  height: 60px;
  border-radius: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.powerup-btn:hover {
  border-color: var(--accent);
  transform: translateY(-2px);
}

.powerup-btn[draggable="true"] {
  cursor: grab;
}

.powerup-btn[draggable="true"]:active {
  cursor: grabbing;
}

.powerup-btn.active {
  border-color: var(--accent);
  background: var(--accent-light);
  box-shadow: 0 0 12px var(--accent-light);
}

.powerup-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
  background: var(--surface);
  border-color: var(--border);
}

.powerup-icon {
  font-size: 28px;
}

.powerup-drag-icon {
  font-size: 40px;
  background: var(--accent-light);
  border-radius: 50%;
  width: 60px;
  height: 60px;
  display: grid;
  place-items: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.powerup-quantity {
  position: absolute;
  bottom: -4px;
  right: -4px;
  background: var(--accent);
  color: white;
  font-size: 12px;
  font-weight: 700;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  display: grid;
  place-items: center;
  border: 2px solid var(--card);
}

/* =================================== */
/* ===== GAME OVER FLOW (NEW) ====== */
/* =================================== */

.calculating-overlay {
  position: absolute;
  inset: 0;
  background: rgba(253, 249, 244, 0.9);
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

.calculating-content {
  text-align: center;
}

.calculating-icon {
  font-size: 48px;
  animation: pulse 1.5s infinite;
}

.calculating-text {
  font-size: 20px;
  font-weight: 700;
  color: var(--text);
  margin-top: 12px;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.8; }
}

.game-over-screen {
  text-align: center;
}

.game-over-title {
  font-size: 28px;
  font-weight: 800;
  color: var(--text);
  margin-bottom: 24px;
}

.results-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.result-stat {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 20px;
}

.stat-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--muted);
  text-transform: uppercase;
  margin-bottom: 8px;
}

.stat-value {
  font-size: 28px;
  font-weight: 800;
  color: var(--text);
}

.result-stat.new-best {
  background: var(--accent-light);
  border-color: var(--accent);
  animation: new-best-glow 2s infinite;
}

@keyframes new-best-glow {
  0%, 100% { box-shadow: 0 0 12px rgba(212, 175, 55, 0); }
  50% { box-shadow: 0 0 16px rgba(212, 175, 55, 0.4); }
}

.new-best-badge {
  display: block;
  font-size: 10px;
  font-weight: 700;
  color: var(--accent);
  margin-top: 4px;
}

.game-over-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  margin-top: 24px;
}

.shop-cta {
  margin-top: 32px;
  padding: 20px;
  background: var(--surface);
  border-radius: 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  text-align: left;
}

.cta-text p {
  font-size: 14px;
  color: var(--muted);
  margin: 4px 0 0;
}

/* =================================== */
/* ===== DAILY REWARD MODAL (NEW) ====== */
/* =================================== */

.daily-reward-modal .modal-body {
  padding-top: 16px;
}

.streak-days-visual {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.reward-day-item {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 16px 8px;
  text-align: center;
  opacity: 0.6;
  position: relative;
}

.reward-day-item.claimed {
  opacity: 1;
  background: var(--accent-light);
}

.reward-day-item.claimed::after {
  content: 'âœ”';
  position: absolute;
  top: 8px;
  right: 8px;
  color: var(--accent);
  font-weight: bold;
}

.reward-day-item.current {
  opacity: 1;
  border-color: var(--accent);
  transform: scale(1.05);
  box-shadow: 0 0 12px var(--accent-light);
}

.reward-day-item:nth-child(7) {
  grid-column: 2 / span 2;
  background: linear-gradient(135deg, var(--accent-light), var(--surface));
}

.reward-day-item .day-label {
  font-size: 12px;
  font-weight: 700;
  color: var(--muted);
}

.reward-day-item .reward-icon {
  font-size: 32px;
  margin: 12px 0;
}

.reward-day-item .reward-amount {
  font-size: 13px;
  font-weight: 600;
  color: var(--text);
  white-space: nowrap;
}

/* =================================== */
/* ===== PHASE 1: RUSH MODE STYLES ===== */
/* =================================== */

/* Enhanced hint pulse animation */
@keyframes hint-pulse {
  0%, 100% { transform: scale(1) translateZ(0); }
  50% { transform: scale(1.1) translateZ(0); box-shadow: 0 0 12px var(--accent); }
}

.tile.hint-pulse .emoji {
  animation: hint-pulse 1s ease-in-out 2;
}

/* Enhanced blast effect */
.blast-enhanced {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  pointer-events: none;
  animation: enhanced-blast 0.3s ease forwards;
}

@keyframes enhanced-blast {
  0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
  50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.8; }
  100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; }
}

/* Rush Mode Timer */
.rush-timer {
  background: linear-gradient(135deg, var(--accent), var(--accent2)) !important;
  color: white !important;
  border: none !important;
  box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3) !important;
}

/* Hype Meter Styles */
.hype-meter {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  margin: 12px 0;
  padding: 12px;
  background: var(--surface);
  border-radius: 16px;
  border: 1px solid var(--border);
}

.hype-label {
  font-size: 12px;
  font-weight: 800;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.hype-bar {
  width: 100%;
  height: 8px;
  background: var(--border);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.hype-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.3s ease, background-color 0.3s ease;
  position: relative;
}

.hype-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: hype-shine 2s infinite;
}

@keyframes hype-shine {
  0% { left: -100%; }
  100% { left: 100%; }
}

.hype-score {
  font-size: 14px;
  font-weight: 700;
  color: var(--text);
}

.cascade-indicator {
  position: absolute;
  top: -8px;
  right: -8px;
  background: var(--accent);
  color: white;
  font-size: 10px;
  font-weight: 800;
  padding: 2px 6px;
  border-radius: 8px;
  animation: cascade-pulse 0.5s ease;
}

@keyframes cascade-pulse {
  0% { transform: scale(0.8); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

/* Rush Mode Stats */
.rush-stats {
  background: var(--surface);
  padding: 10px 16px;
  border-radius: 12px;
  margin-bottom: 12px;
}

/* Cascade Celebration */
.cascade-celebration {
  position: absolute;
  top: 50px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, #ff6b35, #f7b731);
  color: white;
  padding: 8px 16px;
  border-radius: 20px;
  font-weight: 800;
  font-size: 14px;
  animation: cascade-celebration 1.5s ease forwards;
  z-index: 1000;
  pointer-events: none;
  box-shadow: 0 4px 16px rgba(255, 107, 53, 0.4);
}

@keyframes cascade-celebration {
  0% { transform: translateX(-50%) scale(0.5) rotate(-5deg); opacity: 0; }
  20% { transform: translateX(-50%) scale(1.2) rotate(2deg); opacity: 1; }
  80% { transform: translateX(-50%) scale(1) rotate(0deg); opacity: 1; }
  100% { transform: translateX(-50%) scale(0.8); opacity: 0; }
}

/* Enhanced Rush Board */
.rush-board {
  box-shadow: 0 8px 24px rgba(0,0,0,0.1);
  border: 2px solid var(--accent-light);
}

/* Enhanced Progress Bar */
.rush-progress {
  position: relative;
  overflow: hidden;
}

.rush-progress::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 50%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
  animation: progress-shine 2s infinite;
}

@keyframes progress-shine {
  0% { left: -100%; }
  100% { left: 100%; }
}

/* Mobile Responsive Rush Mode */
@media (max-width: 480px) {
  .hype-meter {
    padding: 8px;
    margin: 8px 0;
  }
  
  .hype-label {
    font-size: 10px;
  }
  
  .hype-score {
    font-size: 12px;
  }
  
  .cascade-celebration {
    font-size: 12px;
    padding: 6px 12px;
    top: 40px;
  }
  
  .rush-timer {
    font-size: 16px;
  }
}

// src/GameView.jsx
import React, { useEffect, useRef, useState, useCallback, useMemo } from "react";
import * as audio from "./audio"; // minimal sound hooks
import ShareButtons from "./ShareButtons.jsx";
import { game } from "./utils.js";
import { useStore } from "./store.js"; // NEW: Import Zustand store

// ðŸ†• PHASE 2: Special Cat Types
const SPECIAL_TYPES = {
  WHISKER_STREAK_H: 'whisker_streak_h', // Horizontal line clear
  WHISKER_STREAK_V: 'whisker_streak_v', // Vertical line clear
  BOX_CAT: 'box_cat',                   // 3x3 area clear
  CATNIP_BOMB: 'catnip_bomb',           // Clear all of one type
};

// 1) OPTIMIZE: Enhanced Memoized tile component with special rendering
const MemoizedTile = React.memo(({
  r, c, value, cell, isSelected, isHinted, isBlasting, isSwapping,
  isNewTile, isGrab, isShake, swapTransform, delaySeconds, EMOJI_SIZE, specialType
}) => {
  const isSpecial = !!specialType;
  const isImage = value && typeof value === 'string' && value.startsWith('https://ik.imagekit.io');
  
  // Get special overlay based on type
  const getSpecialOverlay = () => {
    switch(specialType) {
      case SPECIAL_TYPES.WHISKER_STREAK_H:
        return 'âš¡'; // Horizontal lightning
      case SPECIAL_TYPES.WHISKER_STREAK_V:
        return 'âš¡'; // Vertical lightning  
      case SPECIAL_TYPES.BOX_CAT:
        return 'ðŸ’¥'; // Explosion symbol
      case SPECIAL_TYPES.CATNIP_BOMB:
        return 'ðŸŒŸ'; // Star bomb
      default:
        return null;
    }
  };

  const getSpecialBorder = () => {
    switch(specialType) {
      case SPECIAL_TYPES.WHISKER_STREAK_H:
        return '3px solid #00d4ff'; // Cyan for horizontal
      case SPECIAL_TYPES.WHISKER_STREAK_V:
        return '3px solid #ff6b35'; // Orange for vertical
      case SPECIAL_TYPES.BOX_CAT:
        return '3px solid #f7b731'; // Gold for box
      case SPECIAL_TYPES.CATNIP_BOMB:
        return '3px solid #e056fd'; // Purple for bomb
      default:
        return '1px solid var(--border)';
    }
  };
  
  return (
    <div
      key={`tile-${r}-${c}`}
      className={`tile ${isSelected ? "sel" : ""} ${isHinted ? "hint-pulse" : ""} ${isGrab ? "grab" : ""} ${isShake ? "shake" : ""} ${isSpecial ? "special-tile" : ""}`}
      style={{
        left: c * cell,
        top: r * cell,
        width: cell,
        height: cell,
        transform: swapTransform || undefined,
        zIndex: isBlasting ? 10 : isGrab ? 5 : (isSpecial ? 3 : 1),
        transition: isSwapping
          ? "transform 0.16s ease"
          : delaySeconds
          ? `top 0.16s ease ${delaySeconds}s`
          : "top 0.16s ease",
        border: getSpecialBorder(),
        boxShadow: isSpecial ? `0 0 12px ${getSpecialBorder().split(' ')[2]}40` : 'none'
      }}
    >
      <div
        className={`emoji ${isGrab ? "grab" : ""} ${isShake ? "shake" : ""}`}
        style={{ 
          fontSize: isImage ? 'inherit' : Math.floor(cell * EMOJI_SIZE),
          width: isImage ? '85%' : 'auto',
          height: isImage ? '85%' : 'auto',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          position: 'relative'
        }}
      >
        {isImage ? (
          <img 
            src={value} 
            alt="cat" 
            style={{ 
              width: '100%', 
              height: '100%', 
              objectFit: 'contain',
              borderRadius: '8px',
              filter: isSpecial ? 'brightness(1.2) saturate(1.3)' : 'none'
            }}
            draggable={false}
            onError={(e) => {
              console.error('Failed to load cat image:', value);
              e.target.style.display = 'none';
            }}
          />
        ) : (
          value
        )}
        
        {/* Special overlay */}
        {isSpecial && (
          <div className="special-overlay">
            {getSpecialOverlay()}
          </div>
        )}
      </div>
      
      {/* Enhanced blast effect */}
      {isBlasting && (
        <div className="blast-enhanced">
          âœ¨
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  return (
    prevProps.value === nextProps.value &&
    prevProps.isSelected === nextProps.isSelected &&
    prevProps.isHinted === nextProps.isHinted &&
    prevProps.isBlasting === nextProps.isBlasting &&
    prevProps.isSwapping === nextProps.isSwapping &&
    prevProps.isNewTile === nextProps.isNewTile &&
    prevProps.isGrab === nextProps.isGrab &&
    prevProps.isShake === nextProps.isShake &&
    prevProps.swapTransform === nextProps.swapTransform &&
    prevProps.specialType === nextProps.specialType
  );
});

// 2) OPTIMIZE: RAF helper
const useAnimationFrame = () => {
  const requestRef = useRef();
  const previousTimeRef = useRef();

  const animate = useCallback((callback) => {
    const animateFrame = (time) => {
      if (previousTimeRef.current !== undefined) {
        const deltaTime = time - previousTimeRef.current;
        callback(deltaTime);
      }
      previousTimeRef.current = time;
      requestRef.current = requestAnimationFrame(animateFrame);
    };
    requestRef.current = requestAnimationFrame(animateFrame);

    return () => {
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current);
      }
    };
  }, []);

  return animate;
};

// 3) OPTIMIZE: Batched state helper
const useBatchedState = () => {
  const [pendingUpdates, setPendingUpdates] = useState({});
  const timeoutRef = useRef();

  const batchUpdate = useCallback((updates) => {
    setPendingUpdates(prev => ({ ...prev, ...updates }));

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(() => {
      Object.entries(pendingUpdates).forEach(([key, updater]) => {
        if (typeof updater === 'function') {
          updater();
        }
      });
      setPendingUpdates({});
    }, 16);
  }, [pendingUpdates]);

  return batchUpdate;
};

const COLS = 6;  // 6x6 grid for Rush mode
const ROWS = 6;
const CELL_MIN = 36;
const CELL_MAX = 88;
const GAME_DURATION = 60; // 60 seconds for Rush mode
const EMOJI_SIZE = 0.8;

// ðŸ± THE SIX MEOWCHI CATS (Phase 1)
const CAT_SET = [
  "https://ik.imagekit.io/59r2kpz8r/Meowchi/Boba.webp?updatedAt=1756284887939",      // Boba
  "https://ik.imagekit.io/59r2kpz8r/Meowchi/Cheese.webp?updatedAt=1756284888031",    // Cheese  
  "https://ik.imagekit.io/59r2kpz8r/Meowchi/Meowchi.webp?updatedAt=1756284887490",   // Meowchi
  "https://ik.imagekit.io/59r2kpz8r/Meowchi/Oreo%20.webp?updatedAt=1756284888252",   // Oreo
  "https://ik.imagekit.io/59r2kpz8r/Meowchi/Panthera.webp?updatedAt=1756284887810",  // Panthera
  "https://ik.imagekit.io/59r2kpz8r/Meowchi/Patches.webp?updatedAt=1756284888179"    // Patches
];

const randCat = () => CAT_SET[Math.floor(Math.random() * CAT_SET.length)];

// NEW: Power-up definitions
const POWERUP_DEFINITIONS = {
  shuffle: { name: "Paw-sitive Swap", icon: "ðŸ¾" },
  hammer: { name: "Catnip Cookie", icon: "ðŸª" },
  bomb: { name: "Marshmallow Bomb", icon: "ðŸ’£" },
};

// ðŸŽ¯ Meowchi 6x6 Rush Scoring (Updated for Phase 2)
const RUSH_SCORING = {
  3: 60,   // 3-match = 60 points
  4: 120,  // 4-match = 120 points  
  5: 200,  // 5-match = 200 points
  CASCADE_TIME_BONUS: 0.25, // +0.25s per cascade step
  MAX_TIME_BONUS: 5,        // Cap at +5s total per game
  CASCADE_MULTIPLIER: 0.3,   // Each cascade step: Ã—(1 + 0.3 per step)
  
  // ðŸ†• PHASE 2: Special Scoring
  WHISKER_STREAK_BASE: 160,  // +160 base + +15 per tile cleared
  WHISKER_STREAK_PER_TILE: 15,
  BOX_CAT_BASE: 180,         // +180 base + +20 per tile
  BOX_CAT_PER_TILE: 20,
  CATNIP_BOMB_BASE: 420,     // +420 base + +12 per tile
  CATNIP_BOMB_PER_TILE: 12,
};

// ðŸ”¥ Hype Meter Component (unchanged from Phase 1)
const HypeMeter = ({ currentScore, cascadeLevel }) => {
  const tier1 = 1500;
  const tier2 = 4500; 
  const tier3 = 9000;
  
  let currentTier = 0;
  let progress = 0;
  
  if (currentScore >= tier3) {
    currentTier = 3;
    progress = 100;
  } else if (currentScore >= tier2) {
    currentTier = 2;
    progress = ((currentScore - tier2) / (tier3 - tier2)) * 100;
  } else if (currentScore >= tier1) {
    currentTier = 1;
    progress = ((currentScore - tier1) / (tier2 - tier1)) * 100;
  } else {
    progress = (currentScore / tier1) * 100;
  }
  
  const getTierColor = () => {
    switch(currentTier) {
      case 3: return '#ff6b35'; // Hot orange
      case 2: return '#f7b731'; // Gold  
      case 1: return '#26de81'; // Green
      default: return '#74b9ff'; // Blue
    }
  };
  
  const getTierLabel = () => {
    switch(currentTier) {
      case 3: return 'FIRE! ðŸ”¥';
      case 2: return 'HOT! âœ¨'; 
      case 1: return 'WARM ðŸ’«';
      default: return 'HYPE';
    }
  };
  
  return (
    <div className="hype-meter">
      <div className="hype-label">{getTierLabel()}</div>
      <div className="hype-bar">
        <div 
          className="hype-fill" 
          style={{ 
            width: `${Math.min(progress, 100)}%`,
            backgroundColor: getTierColor(),
            boxShadow: `0 0 10px ${getTierColor()}40`
          }}
        />
      </div>
      <div className="hype-score">{currentScore.toLocaleString()}</div>
      {cascadeLevel > 0 && (
        <div className="cascade-indicator">
          CASCADE x{cascadeLevel + 1}
        </div>
      )}
    </div>
  );
};

export default function GameView({
  onExit,
  settings,
  userTelegramId,
}) {
  const containerRef = useRef(null);
  const boardRef = useRef(null);
  const [cell, setCell] = useState(48);

  // Grid state
  const [grid, setGrid] = useState(() => initSolvableGrid());
  const gridRef = useRef(grid);
  gridRef.current = grid;
  
  // ðŸ†• PHASE 2: Special cats grid
  const [specialGrid, setSpecialGrid] = useState(() => Array.from({ length: ROWS }, () => Array(COLS).fill(null)));
  const specialGridRef = useRef(specialGrid);
  specialGridRef.current = specialGrid;

  // Selection / hint / animation
  const [sel, setSel] = useState(null);
  const [hint, setHint] = useState(null);
  const [swapping, setSwapping] = useState(null);

  // Stats
  const [score, setScore] = useState(0);
  const [moves, setMoves] = useState(20);
  const [combo, setCombo] = useState(0);
  const [fx, setFx] = useState([]);
  const [blast, setBlast] = useState(new Set());
  const [timeLeft, setTimeLeft] = useState(GAME_DURATION);

  // Enhanced Rush Mode Stats
  const [totalTimeBonusEarned, setTotalTimeBonusEarned] = useState(0);
  const [currentCascadeLevel, setCurrentCascadeLevel] = useState(0);
  const [gameStartTime, setGameStartTime] = useState(Date.now());
  const [moveCount, setMoveCount] = useState(0);
  const [maxComboAchieved, setMaxComboAchieved] = useState(0);

  const [newTiles, setNewTiles] = useState(new Set());
  const [fallDelay, setFallDelay] = useState({});

  const [paused, setPaused] = useState(false);
  const [animating, setAnimating] = useState(false);
  const animatingRef = useRef(animating);
  animatingRef.current = animating;

  const [grabTile, setGrabTile] = useState(null);
  const [shake, setShake] = useState(new Set());
  
  const [gameOverState, setGameOverState] = useState(null);
  const [draggedPowerup, setDraggedPowerup] = useState(null);
  const [draggedIconStyle, setDraggedIconStyle] = useState({});

  // Power-up state
  const [activePowerup, setActivePowerup] = useState(null);
  const powerups = useStore(s => s.powerups);
  const setPowerups = useStore(s => s.setPowerups);

  // ðŸ†• PHASE 2: Special activation mode
  const [specialActivationMode, setSpecialActivationMode] = useState(false);

  // NEW: Function to consume a power-up
  const consumePowerup = async (powerupKey) => {
    try {
      setPowerups({ ...powerups, [powerupKey]: (powerups[powerupKey] || 1) - 1 });
      
      const response = await fetch('/api/powerups/use', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          telegram_id: userTelegramId,
          item_id: powerupKey,
          initData: window.Telegram?.WebApp?.initData,
        }),
      });
      
      if (!response.ok) {
        setPowerups(powerups);
        console.error("Failed to consume power-up on server");
      }
    } catch (error) {
      setPowerups(powerups);
      console.error("Error consuming powerup:", error);
    }
  };

  // ðŸ†• PHASE 2: Special Detection Functions

  // Detect 4-in-a-row/column for Whisker-Streak
  const detect4Match = (matches) => {
    const specials = [];
    
    // Group matches by position to find 4+ consecutive
    const horizontalGroups = {};
    const verticalGroups = {};
    
    matches.forEach(([r, c]) => {
      // Group horizontal matches by row
      if (!horizontalGroups[r]) horizontalGroups[r] = [];
      horizontalGroups[r].push(c);
      
      // Group vertical matches by column
      if (!verticalGroups[c]) verticalGroups[c] = [];
      verticalGroups[c].push(r);
    });
    
    // Check horizontal groups for 4+
    Object.entries(horizontalGroups).forEach(([row, cols]) => {
      cols.sort((a, b) => a - b);
      if (cols.length >= 4) {
        // Create horizontal Whisker-Streak in the middle
        const middleCol = cols[Math.floor(cols.length / 2)];
        specials.push({
          r: parseInt(row),
          c: middleCol,
          type: SPECIAL_TYPES.WHISKER_STREAK_H
        });
      }
    });
    
    // Check vertical groups for 4+
    Object.entries(verticalGroups).forEach(([col, rows]) => {
      rows.sort((a, b) => a - b);
      if (rows.length >= 4) {
        // Create vertical Whisker-Streak in the middle
        const middleRow = rows[Math.floor(rows.length / 2)];
        specials.push({
          r: middleRow,
          c: parseInt(col),
          type: SPECIAL_TYPES.WHISKER_STREAK_V
        });
      }
    });
    
    return specials;
  };

  // Detect 5-in-a-line for Catnip Bomb
  const detect5InLine = (matches) => {
    const specials = [];
    
    // Check for exactly 5 in a straight line
    const horizontalGroups = {};
    const verticalGroups = {};
    
    matches.forEach(([r, c]) => {
      if (!horizontalGroups[r]) horizontalGroups[r] = [];
      horizontalGroups[r].push(c);
      
      if (!verticalGroups[c]) verticalGroups[c] = [];
      verticalGroups[c].push(r);
    });
    
    // Check for exactly 5 horizontal
    Object.entries(horizontalGroups).forEach(([row, cols]) => {
      if (cols.length >= 5) {
        cols.sort((a, b) => a - b);
        const middleCol = cols[Math.floor(cols.length / 2)];
        specials.push({
          r: parseInt(row),
          c: middleCol,
          type: SPECIAL_TYPES.CATNIP_BOMB
        });
      }
    });
    
    // Check for exactly 5 vertical
    Object.entries(verticalGroups).forEach(([col, rows]) => {
      if (rows.length >= 5) {
        rows.sort((a, b) => a - b);
        const middleRow = rows[Math.floor(rows.length / 2)];
        specials.push({
          r: middleRow,
          c: parseInt(col),
          type: SPECIAL_TYPES.CATNIP_BOMB
        });
      }
    });
    
    return specials;
  };

  // Detect L/T shapes for Box Cat (simplified version)
  const detectLTShape = (grid, matches) => {
    const specials = [];
    
    // For Phase 2, we'll use a simplified approach:
    // If we have 5+ matches and they form a rough L or T, create a Box Cat
    if (matches.length >= 5) {
      // Find the center point of the match group
      const centerR = Math.round(matches.reduce((sum, [r]) => sum + r, 0) / matches.length);
      const centerC = Math.round(matches.reduce((sum, [, c]) => sum + c, 0) / matches.length);
      
      // Check if this forms an L or T pattern (simplified)
      const hasHorizontal = matches.some(([r, c]) => r === centerR && Math.abs(c - centerC) >= 1);
      const hasVertical = matches.some(([r, c]) => c === centerC && Math.abs(r - centerR) >= 1);
      
      if (hasHorizontal && hasVertical && matches.length >= 5) {
        specials.push({
          r: centerR,
          c: centerC,
          type: SPECIAL_TYPES.BOX_CAT
        });
      }
    }
    
    return specials;
  };

  // ðŸ†• PHASE 2: Special Activation Functions

  const activateWhiskerStreak = (r, c, direction, targetCat) => {
    const g = cloneGrid(gridRef.current);
    const sg = cloneGrid(specialGridRef.current);
    let tilesCleared = 0;
    
    if (direction === 'horizontal') {
      // Clear entire row
      for (let col = 0; col < COLS; col++) {
        if (g[r][col] !== null) {
          g[r][col] = null;
          sg[r][col] = null;
          tilesCleared++;
        }
      }
    } else {
      // Clear entire column
      for (let row = 0; row < ROWS; row++) {
        if (g[row][c] !== null) {
          g[row][c] = null;
          sg[row][c] = null;
          tilesCleared++;
        }
      }
    }
    
    const points = RUSH_SCORING.WHISKER_STREAK_BASE + (tilesCleared * RUSH_SCORING.WHISKER_STREAK_PER_TILE);
    setScore(s => s + points);
    
    audio.play?.('powerup_spawn', { volume: 0.8 });
    console.log(`âš¡ Whisker-Streak activated: ${tilesCleared} tiles, ${points} points`);
    
    return { grid: g, specialGrid: sg };
  };

  const activateBoxCat = (r, c, targetCat) => {
    const g = cloneGrid(gridRef.current);
    const sg = cloneGrid(specialGridRef.current);
    let tilesCleared = 0;
    
    // Clear 3x3 area around the Box Cat
    for (let row = r - 1; row <= r + 1; row++) {
      for (let col = c - 1; col <= c + 1; col++) {
        if (inBounds(row, col) && g[row][col] !== null) {
          g[row][col] = null;
          sg[row][col] = null;
          tilesCleared++;
        }
      }
    }
    
    const points = RUSH_SCORING.BOX_CAT_BASE + (tilesCleared * RUSH_SCORING.BOX_CAT_PER_TILE);
    setScore(s => s + points);
    
    audio.play?.('powerup_spawn', { volume: 0.9 });
    console.log(`ðŸ’¥ Box Cat activated: ${tilesCleared} tiles, ${points} points`);
    
    return { grid: g, specialGrid: sg };
  };

  const activateCatnipBomb = (r, c, targetCat) => {
    const g = cloneGrid(gridRef.current);
    const sg = cloneGrid(specialGridRef.current);
    let tilesCleared = 0;
    
    // Clear all cats of the target type
    for (let row = 0; row < ROWS; row++) {
      for (let col = 0; col < COLS; col++) {
        if (g[row][col] === targetCat && (row !== r || col !== c)) {
          g[row][col] = null;
          sg[row][col] = null;
          tilesCleared++;
        }
      }
    }
    
    // Also clear the bomb itself
    g[r][c] = null;
    sg[r][c] = null;
    tilesCleared++;
    
    const points = RUSH_SCORING.CATNIP_BOMB_BASE + (tilesCleared * RUSH_SCORING.CATNIP_BOMB_PER_TILE);
    setScore(s => s + points);
    
    audio.play?.('powerup_spawn', { volume: 1.0 });
    console.log(`ðŸŒŸ Catnip Bomb activated: ${tilesCleared} tiles, ${points} points`);
    
    return { grid: g, specialGrid: sg };
  };

  // Enable closing confirmation during gameplay
  useEffect(() => {
    const tg = window.Telegram?.WebApp;
    if (tg?.enableClosingConfirmation) {
      tg.enableClosingConfirmation();
      console.log('âœ… Closing confirmation enabled');
    }

    return () => {
      if (tg?.disableClosingConfirmation) {
        tg.disableClosingConfirmation();
        console.log('âœ… Closing confirmation disabled');
      }
    };
  }, []);

  // Keep refs for async
  const movesRef = useRef(moves);
  movesRef.current = moves;
  const timeLeftRef = useRef(timeLeft);
  timeLeftRef.current = timeLeft;
  const scoreRef = useRef(score);
  scoreRef.current = score;
  const maxComboAchievedRef = useRef(maxComboAchieved);
  maxComboAchievedRef.current = maxComboAchieved;

  // Responsive sizing
  useEffect(() => {
    const compute = () => {
      const el = containerRef.current;
      if (!el) return;
      const pad = 16;
      const w = el.clientWidth - pad * 2;
      const h = el.clientHeight - 84;
      const size = Math.floor(Math.min(w / COLS, h / ROWS));
      setCell(Math.max(CELL_MIN, Math.min(size, CELL_MAX)));
    };
    compute();
    let ro;
    if (typeof ResizeObserver !== "undefined" && containerRef.current) {
      ro = new ResizeObserver(compute);
      ro.observe(containerRef.current);
    }
    window.addEventListener("resize", compute);
    return () => {
      ro?.disconnect();
      window.removeEventListener("resize", compute);
    };
  }, []);

  useEffect(() => {
    window.currentGameScore = score;
  }, [score]);

  // Enhanced Timer with Cascade Bonuses
  useEffect(() => {
    if (paused || gameOverState) return;
    const timer = setInterval(() => {
      setTimeLeft((prev) => {
        if (prev <= 1) {
          clearInterval(timer);
          finish();
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
    return () => clearInterval(timer);
  }, [paused, gameOverState]);

  // Timer tick sounds
  const lastTickRef = useRef(null);
  useEffect(() => {
    if (!settings?.sound) return;
    if (timeLeftRef.current <= 0) return;
    if (timeLeftRef.current <= 10) {
      if (lastTickRef.current !== timeLeftRef.current) {
        lastTickRef.current = timeLeftRef.current;
        audio.play?.("timer_tick", { volume: 0.35 });
      }
    }
    if (timeLeftRef.current === 5) {
      audio.play?.("timer_hurry", { volume: 0.7 });
    }
  }, [timeLeft, settings?.sound]);

  function haptic(ms = 12) {
    if (!settings?.haptics) return;
    try {
      navigator.vibrate?.(ms);
    } catch {}
  }

  // Rush Mode Cascade Time Bonus
  const addCascadeTimeBonus = (cascadeSteps) => {
    const timeBonus = Math.min(
      cascadeSteps * RUSH_SCORING.CASCADE_TIME_BONUS,
      RUSH_SCORING.MAX_TIME_BONUS - totalTimeBonusEarned
    );
    
    if (timeBonus > 0) {
      setTimeLeft(prev => prev + timeBonus);
      setTotalTimeBonusEarned(prev => prev + timeBonus);
      console.log(`â° Time bonus: +${timeBonus}s (Total: ${totalTimeBonusEarned + timeBonus}s)`);
    }
  };

  async function submitGameScore(finalScore) {
    if (!userTelegramId) {
      console.log("No Telegram ID, skipping score submission");
      return { user_needs_profile: false, coins_earned: 0 };
    }

    const gameScore = Math.max(finalScore, 0);
    const currentMaxCombo = maxComboAchievedRef.current;

    const coinsEarned = game.calculateCoins(gameScore, currentMaxCombo);

    try {
      const tg = window.Telegram?.WebApp;
      const gameData = {
        telegram_id: userTelegramId,
        score: gameScore,
        coins_earned: coinsEarned,
        max_combo: currentMaxCombo,
        game_duration: Math.floor((Date.now() - gameStartTime) / 1000),
      };

      if (tg?.initData) {
        gameData.initData = tg.initData;
      }

      const response = await fetch("/api/game/complete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(gameData),
      });

      const result = await response.json();
      if (!response.ok) {
        console.error("Score submission failed:", result.error);
        return { user_needs_profile: false, coins_earned: coinsEarned };
      }

      return { ...result, coins_earned: coinsEarned };
    } catch (error) {
      console.error("Error submitting score:", error);
      return { user_needs_profile: false, coins_earned: coinsEarned };
    }
  }

  // ðŸ†• PHASE 2: Enhanced Pointer Interactions with Special Activation
  useEffect(() => {
    const el = boardRef.current;
    if (!el || paused) return;
    let drag = null;
    const thresholdBase = 18;

    const rc = (e) => {
      const rect = el.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width - 1, e.clientX - rect.left));
      const y = Math.max(0, Math.min(rect.height - 1, e.clientY - rect.top));
      return { r: Math.floor(y / cell), c: Math.floor(x / cell), x, y };
    };

    const down = (e) => {
      if (timeLeftRef.current <= 0) return;
      el.setPointerCapture?.(e.pointerId);
      const p = rc(e);
      if (!inBounds(p.r, p.c)) return;

      // ðŸ†• PHASE 2: Check for special activation
      const specialType = specialGridRef.current[p.r][p.c];
      if (specialType) {
        const targetCat = gridRef.current[p.r][p.c];
        let result;
        
        if (specialType === SPECIAL_TYPES.WHISKER_STREAK_H) {
          result = activateWhiskerStreak(p.r, p.c, 'horizontal', targetCat);
        } else if (specialType === SPECIAL_TYPES.WHISKER_STREAK_V) {
          result = activateWhiskerStreak(p.r, p.c, 'vertical', targetCat);
        } else if (specialType === SPECIAL_TYPES.BOX_CAT) {
          result = activateBoxCat(p.r, p.c, targetCat);
        } else if (specialType === SPECIAL_TYPES.CATNIP_BOMB) {
          result = activateCatnipBomb(p.r, p.c, targetCat);
        }
        
        if (result) {
          setGrid(result.grid);
          setSpecialGrid(result.specialGrid);
          haptic(15);
          
          // Trigger cascade after special activation
          setTimeout(() => {
            optimizedResolveCascades(result.grid, result.specialGrid, () => {});
          }, 100);
        }
        return;
      }

      // Regular powerup handling
      if (activePowerup) {
        const g = cloneGrid(gridRef.current);
        if (activePowerup === 'hammer') {
          const targetCat = g[p.r][p.c];
          if (CAT_SET.includes(targetCat)) {
            for (let r = 0; r < ROWS; r++) {
              for (let c = 0; c < COLS; c++) {
                if (g[r][c] === targetCat) g[r][c] = null;
              }
            }
            audio.play?.('powerup_spawn', { volume: 0.7 });
            optimizedResolveCascades(g, specialGridRef.current, () => {});
            consumePowerup('hammer');
            setActivePowerup(null);
          } else {
            haptic(8);
            audio.play?.("swap_invalid", { volume: 0.5 });
          }
        } else if (activePowerup === 'bomb') {
          for (let r = p.r - 1; r <= p.r + 1; r++) {
            for (let c = p.c - 1; c <= p.c + 1; c++) {
              if (inBounds(r, c)) g[r][c] = null;
            }
          }
          audio.play?.('powerup_spawn', { volume: 0.8 });
          optimizedResolveCascades(g, specialGridRef.current, () => {});
          consumePowerup('bomb');
          setActivePowerup(null);
        }
        return;
      }

      // Regular drag behavior
      drag = { r: p.r, c: p.c, x: p.x, y: p.y, dragging: false };
      setSel({ r: p.r, c: p.c });
      setGrabTile({ r: p.r, c: p.c });
      haptic(5);
    };

    const move = (e) => {
      if (!drag || timeLeftRef.current <= 0) return;
      const p = rc(e);
      const dx = p.x - drag.x;
      const dy = p.y - drag.y;
      const threshold = Math.min(thresholdBase, Math.floor(cell * 0.35));
      if (!drag.dragging && Math.hypot(dx, dy) > threshold) {
        drag.dragging = true;
        haptic(8);
        const horiz = Math.abs(dx) > Math.abs(dy);
        const tr = drag.r + (horiz ? 0 : dy > 0 ? 1 : -1);
        const tc = drag.c + (horiz ? (dx > 0 ? 1 : -1) : 0);
        if (inBounds(tr, tc)) setSel({ r: tr, c: tc });
      }
    };

    const up = (e) => {
      if (!drag) return;
      const p = rc(e);
      const dx = p.x - drag.x;
      const dy = p.y - drag.y;
      if (!drag.dragging) {
        setSel({ r: drag.r, c: drag.c });
      } else {
        if (timeLeftRef.current > 0) {
          const horiz = Math.abs(dx) > Math.abs(dy);
          const tr = drag.r + (horiz ? 0 : dy > 0 ? 1 : -1);
          const tc = drag.c + (horiz ? (dx > 0 ? 1 : -1) : 0);
          if (inBounds(tr, tc)) {
            trySwap(drag.r, drag.c, tr, tc);
            haptic(12);
          }
        }
        setSel(null);
      }
      drag = null;
      setGrabTile(null);
    };

    el.addEventListener("pointerdown", down, { passive: true });
    el.addEventListener("pointermove", move, { passive: true });
    el.addEventListener("pointerup", up, { passive: true });
    el.addEventListener("pointercancel", up, { passive: true });
    return () => {
      el.removeEventListener("pointerdown", down);
      el.removeEventListener("pointermove", move);
      el.removeEventListener("pointerup", up);
      el.removeEventListener("pointercancel", up);
    };
  }, [cell, paused, settings?.haptics, activePowerup]);

  function trySwap(r1, c1, r2, c2) {
    if (timeLeft <= 0) return;
    if (Math.abs(r1 - r2) + Math.abs(c1 - c2) !== 1) return;

    const g = cloneGrid(gridRef.current);
    const sg = cloneGrid(specialGridRef.current);
    
    // Swap both regular and special grids
    [g[r1][c1], g[r2][c2]] = [g[r2][c2], g[r1][c1]];
    [sg[r1][c1], sg[r2][c2]] = [sg[r2][c2], sg[r1][c1]];
    
    const matches = findMatches(g);

    if (matches.length === 0) {
      const s = new Set(shake);
      s.add(`${r1}-${c1}`);
      s.add(`${r2}-${c2}`);
      setShake(s);
      setTimeout(() => {
        setShake((prev) => {
          const n = new Set(prev);
          n.delete(`${r1}-${c1}`);
          n.delete(`${r2}-${c2}`);
          return n;
        });
      }, 140);
      haptic(8);
      audio.play?.("swap_invalid", { volume: 0.5 });
      setSel({ r: r1, c: c1 });
      setTimeout(() => setSel(null), 80);

      window.Telegram?.WebApp?.HapticFeedback?.notificationOccurred('error');
      return;
    }

    window.Telegram?.WebApp?.HapticFeedback?.impactOccurred('light');

    audio.play?.("swap", { volume: 0.6 });
    setMoveCount((prev) => prev + 1);
    setSwapping({ from: { r: r1, c: c1 }, to: { r: r2, c: c2 } });
    setTimeout(() => {
      setGrid(g);
      setSpecialGrid(sg);
      setSwapping(null);
      setMoves((m) => Math.max(0, m - 1));
      optimizedResolveCascades(g, sg, () => {
        if (timeLeftRef.current <= 0) finish();
      });
    }, 200);
  }

  // ðŸš€ ENHANCED: Phase 2 Cascade Resolution with Special Creation
  function optimizedResolveCascades(startGrid, startSpecialGrid, done) {
    setAnimating(true);
    let g = cloneGrid(startGrid);
    let sg = cloneGrid(startSpecialGrid);
    let cascadeSteps = 0;

    const step = () => {
      const matches = findMatches(g);
      if (matches.length === 0) {
        React.startTransition(() => {
          setGrid(g);
          setSpecialGrid(sg);
          setNewTiles(new Set());
          setFallDelay({});
          setCurrentCascadeLevel(0);

          // Add time bonus based on cascade steps
          if (cascadeSteps > 0) {
            addCascadeTimeBonus(cascadeSteps);
            setMaxComboAchieved(prev => {
              const newMax = Math.max(prev, cascadeSteps);
              maxComboAchievedRef.current = newMax;
              return newMax;
            });
          }

          setTimeout(() => setFx([]), 800);
          ensureSolvable();
          setAnimating(false);
          done && done();
        });
        return;
      }

      audio.play?.("match_pop", { volume: 0.5 });
      cascadeSteps++;
      setCurrentCascadeLevel(cascadeSteps);

      // ðŸ†• PHASE 2: Create specials from matches before clearing
      const newSpecials = [];
      
      // Detect 5-in-line first (Catnip Bomb)
      const bombSpecials = detect5InLine(matches);
      newSpecials.push(...bombSpecials);
      
      // Then detect L/T shapes (Box Cat)
      if (bombSpecials.length === 0) { // Only if no bomb was created
        const boxSpecials = detectLTShape(g, matches);
        newSpecials.push(...boxSpecials);
      }
      
      // Finally detect 4-match (Whisker-Streak)
      if (newSpecials.length === 0) { // Only if no other special was created
        const streakSpecials = detect4Match(matches);
        newSpecials.push(...streakSpecials);
      }

      const keys = matches.map(([r, c]) => `${r}:${c}`);
      setBlast(new Set(keys));

      const fxId = Date.now();
      setFx((prev) => [
        ...prev.slice(-5),
        ...matches.slice(0, 10).map((m, i) => ({
          id: fxId + i,
          x: m[1] * cell,
          y: m[0] * cell,
        })),
      ]);

      // Rush Mode Scoring System
      const matchSize = matches.length;
      let basePoints = 0;
      
      if (matchSize >= 5) {
        basePoints = RUSH_SCORING[5] * Math.floor(matchSize / 5) + RUSH_SCORING[3] * (matchSize % 5);
      } else if (matchSize >= 4) {
        basePoints = RUSH_SCORING[4] * Math.floor(matchSize / 4) + RUSH_SCORING[3] * (matchSize % 4);
      } else {
        basePoints = RUSH_SCORING[3] * Math.floor(matchSize / 3);
      }

      // Apply cascade multiplier
      const cascadeMultiplier = 1 + (cascadeSteps * RUSH_SCORING.CASCADE_MULTIPLIER);
      const pointsEarned = Math.floor(basePoints * cascadeMultiplier);
      
      setScore((s) => s + pointsEarned);

      // Clear matched tiles
      matches.forEach(([r, c]) => {
        g[r][c] = null;
        // Don't clear specials that were just created
        if (!newSpecials.some(special => special.r === r && special.c === c)) {
          sg[r][c] = null;
        }
      });

      // ðŸ†• PHASE 2: Place new specials AFTER clearing matches
      newSpecials.forEach(special => {
        // Keep the original cat at the special position
        if (g[special.r][special.c] === null) {
          g[special.r][special.c] = randCat(); // Generate new cat for the special
        }
        sg[special.r][special.c] = special.type;
        console.log(`âœ¨ Special created: ${special.type} at (${special.r}, ${special.c})`);
      });

      setGrid(cloneGrid(g));
      setSpecialGrid(cloneGrid(sg));
      setTimeout(() => setBlast(new Set()), 80);

      setTimeout(() => {
        const delayMap = {};
        for (let c = 0; c < COLS; c++) {
          const nullsBelow = new Array(ROWS).fill(0);
          let count = 0;
          for (let r = ROWS - 1; r >= 0; r--) {
            nullsBelow[r] = count;
            if (g[r][c] === null) count++;
          }
          for (let r = ROWS - 1; r >= 0; r--) {
            if (g[r][c] != null) {
              const dist = nullsBelow[r];
              const newR = r + dist;
              if (dist > 0) {
                delayMap[`${newR}-${c}`] = Math.min(0.03, dist * 0.008);
              }
            }
          }
        }

        applyGravity(g, sg); // Apply gravity to both grids
        const empties = new Set();
        for (let r = 0; r < ROWS; r++)
          for (let c = 0; c < COLS; c++) if (g[r][c] === null) empties.add(`${r}-${c}`);
        refill(g);

        React.startTransition(() => {
          setNewTiles(empties);
          setFallDelay(delayMap);
          setGrid(cloneGrid(g));
          setSpecialGrid(cloneGrid(sg));
        });

        setTimeout(() => {
          setNewTiles(new Set());
          setTimeout(step, 40);
        }, 80);
      }, 60);
    };
    step();
  }

  function doHint() {
    if (timeLeft <= 0) return;
    const m = findFirstMove(gridRef.current);
    if (!m) {
      shuffleBoard();
      return;
    }
    setHint(m);
    setTimeout(() => setHint(null), 1200);
    haptic(10);
  }

  function shuffleBoard() {
    if (timeLeft <= 0) return;
    const g = shuffleToSolvable(gridRef.current);
    const sg = Array.from({ length: ROWS }, () => Array(COLS).fill(null)); // Reset specials
    setGrid(g);
    setSpecialGrid(sg);
    haptic(12);
  }

  function ensureSolvable() {
    if (!hasAnyMove(gridRef.current)) {
      const g = shuffleToSolvable(gridRef.current);
      const sg = Array.from({ length: ROWS }, () => Array(COLS).fill(null)); // Reset specials
      setGrid(g);
      setSpecialGrid(sg);
    }
  }

  async function finish() {
    setGameOverState('calculating');
    const finalScore = scoreRef.current;
    const finalMaxCombo = maxComboAchievedRef.current;
    
    const result = await submitGameScore(finalScore);

    const serverCoins = Math.max(0, Number(result?.coins_earned ?? 0));
    if (serverCoins > 0 && settings?.sound) {
      audio.play?.("coin", { volume: 0.7 });
    }
    if (settings?.sound) {
      if (finalScore > 0) audio.play?.("finish_win", { volume: 0.8 });
      else audio.play?.("finish_lose", { volume: 0.7 });
    }

    const gameResultWithSharing = {
      score: finalScore,
      coins: serverCoins,
      moves_used: moveCount,
      max_combo: finalMaxCombo,
      gameSubmitted: !!result,
      showSharing: true,
    };
    
    setTimeout(() => {
      onExit(gameResultWithSharing);
    }, 500);
  }

  function resetGame() {
    if (timeLeft <= 0 && !paused) return;
    setGrid(initSolvableGrid());
    setSpecialGrid(Array.from({ length: ROWS }, () => Array(COLS).fill(null)));
    setScore(0);
    setMoves(20);
    setCombo(0);
    setSel(null);
    setHint(null);
    setSwapping(null);
    setFallDelay({});
    setNewTiles(new Set());
    setTimeLeft(GAME_DURATION);
    setGameStartTime(Date.now());
    setMoveCount(0);
    setMaxComboAchieved(0);
    setTotalTimeBonusEarned(0);
    setCurrentCascadeLevel(0);
    setFx([]);
    maxComboAchievedRef.current = 0;
    scoreRef.current = 0;
  }

  const handlePowerupSelect = (key) => {
    if (powerups[key] > 0) {
      if (key === 'shuffle') {
        shuffleBoard();
        consumePowerup('shuffle');
      } else {
        setActivePowerup(activePowerup === key ? null : key);
      }
      haptic(10);
    }
  };
  
  const handlePowerupDragStart = (e, key, icon) => {
    if (powerups[key] > 0 && key !== 'shuffle') {
      setDraggedPowerup({ key, icon });
      const empty = new Image();
      e.dataTransfer.setDragImage(empty, 0, 0);
      haptic(8);
    } else {
      e.preventDefault();
    }
  };

  const handlePowerupDragEnd = () => {
    setDraggedPowerup(null);
    setDraggedIconStyle({});
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    if (draggedPowerup) {
      setDraggedIconStyle({
        position: 'fixed',
        left: e.clientX,
        top: e.clientY,
        transform: 'translate(-50%, -50%)',
        pointerEvents: 'none',
        zIndex: 1000,
      });
    }
  };

  const handleDrop = (e) => {
    e.preventDefault();
    if (!draggedPowerup || !boardRef.current) return;

    const rect = boardRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const r = Math.floor(y / cell);
    const c = Math.floor(x / cell);

    if (inBounds(r, c)) {
      applyPowerup(draggedPowerup.key, r, c);
    }
    handlePowerupDragEnd();
  };

  const applyPowerup = (key, r, c) => {
    const g = cloneGrid(gridRef.current);
    const sg = cloneGrid(specialGridRef.current);
    let applied = false;

    if (key === 'hammer') {
      const targetCat = g[r][c];
      if (CAT_SET.includes(targetCat)) {
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            if (g[row][col] === targetCat) {
              g[row][col] = null;
              sg[row][col] = null;
            }
          }
        }
        applied = true;
      }
    } else if (key === 'bomb') {
      for (let row = r - 1; row <= r + 1; row++) {
        for (let col = c - 1; col <= c + 1; col++) {
          if (inBounds(row, col)) {
            g[row][col] = null;
            sg[row][col] = null;
          }
        }
      }
      applied = true;
    }

    if (applied) {
      audio.play?.('powerup_spawn', { volume: 0.8 });
      optimizedResolveCascades(g, sg, () => {});
      consumePowerup(key);
    } else {
      haptic(8);
      audio.play?.("swap_invalid", { volume: 0.5 });
    }
  };

  const boardW = cell * COLS;
  const boardH = cell * ROWS;

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  };

  const getTimerColor = () => {
    if (timeLeft <= 10) return "#e74c3c";
    if (timeLeft <= 30) return "#f39c12";
    return "#27ae60";
  };

  const optimizedGridRender = useMemo(() => {
    return grid.map((row, r) =>
      row.map((v, c) => {
        const isSelected = sel && sel.r === r && sel.c === c;
        const isHinted =
          hint &&
          ((hint[0][0] === r && hint[0][1] === c) ||
            (hint[1][0] === r && hint[1][1] === c));
        const isBlasting = blast.has(`${r}:${c}`);

        let swapTransform = "";
        if (swapping) {
          if (swapping.from.r === r && swapping.from.c === c) {
            const dx = (swapping.to.c - swapping.from.c) * cell;
            const dy = (swapping.to.r - swapping.from.r) * cell;
            swapTransform = `translate(${dx}px, ${dy}px)`;
          } else if (swapping.to.r === r && swapping.to.c === c) {
            const dx = (swapping.from.c - swapping.to.c) * cell;
            const dy = (swapping.from.r - swapping.to.r) * cell;
            swapTransform = `translate(${dx}px, ${dy}px)`;
          }
        }

        const isSwapping =
          !!swapping &&
          ((swapping.from.r === r && swapping.from.c === c) ||
            (swapping.to.r === r && swapping.to.c === c));

        const tileKey = `${r}-${c}`;
        const isNewTile = newTiles.has(tileKey);
        const isGrab = grabTile && grabTile.r === r && grabTile.c === c;
        const isShake = shake.has(tileKey);
        const delaySeconds = isSwapping ? 0 : fallDelay[tileKey] || 0;
        const specialType = specialGrid[r] && specialGrid[r][c];

        return (
          <MemoizedTile
            key={tileKey}
            r={r}
            c={c}
            value={v}
            cell={cell}
            isSelected={isSelected}
            isHinted={isHinted}
            isBlasting={isBlasting}
            isSwapping={isSwapping}
            isNewTile={isNewTile}
            isGrab={isGrab}
            isShake={isShake}
            swapTransform={swapTransform}
            delaySeconds={delaySeconds}
            EMOJI_SIZE={EMOJI_SIZE}
            specialType={specialType}
          />
        );
      })
    );
  }, [grid, specialGrid, sel, hint, blast, swapping, newTiles, grabTile, shake, fallDelay, cell]);

  useEffect(() => {
    const cleanup = [];
    return () => {
      cleanup.forEach(clearTimeout);
      cleanup.forEach(clearInterval);
    };
  }, []);

  return (
    <div className="section board-wrap" ref={containerRef} onDragOver={handleDragOver}>
      {draggedPowerup && (
        <div className="powerup-drag-icon" style={draggedIconStyle}>
          {draggedPowerup.icon}
        </div>
      )}
      {gameOverState === 'calculating' && (
        <div className="calculating-overlay">
          <div className="calculating-content">
            <div className="calculating-icon">â°</div>
            <div className="calculating-text">Time's Up!</div>
          </div>
        </div>
      )}
      
      {/* Rush Mode Timer Display */}
      <div
        className="timer-display rush-timer"
        style={{
          textAlign: "center",
          marginBottom: "12px",
          fontSize: "20px",
          fontWeight: "800",
          color: getTimerColor(),
          padding: "8px 16px",
          background: "var(--card)",
          borderRadius: "16px",
          border: "2px solid",
          borderColor: getTimerColor(),
          boxShadow: `0 0 0 3px ${getTimerColor()}20`,
        }}
      >
        âš¡ RUSH MODE âš¡ {formatTime(timeLeft)}
        {totalTimeBonusEarned > 0 && (
          <div style={{ fontSize: "12px", opacity: 0.8 }}>
            +{totalTimeBonusEarned.toFixed(1)}s bonus earned
          </div>
        )}
      </div>

      {/* ðŸ†• PHASE 2: Special Instructions */}
      <div className="special-instructions">
        <div className="instruction-text">
          âœ¨ Tap special cats to activate! âš¡ Line Clear â€¢ ðŸ’¥ Area Blast â€¢ ðŸŒŸ Color Bomb
        </div>
      </div>

      {/* Hype Meter */}
      <HypeMeter currentScore={score} cascadeLevel={currentCascadeLevel} />

      {/* Enhanced Rush Mode Stats */}
      <div className="row rush-stats">
        <div>
          <span className="muted">Score</span> <b>{score.toLocaleString()}</b>
        </div>
        <div>
          <span className="muted">Swaps</span> <b>{moveCount}</b>
        </div>
        <div>
          <span className="muted">Best</span> <b>{maxComboAchieved}x</b>
        </div>
      </div>

      {/* Enhanced Cascade Celebration */}
      {currentCascadeLevel > 0 && (
        <div className="cascade-celebration">
          ðŸŒŸ CASCADE COMBO x{currentCascadeLevel}! ðŸŒŸ
        </div>
      )}

      <div
        ref={boardRef}
        className="board rush-board"
        style={{ width: boardW, height: boardH }}
        onDrop={handleDrop}
        onDragOver={(e) => e.preventDefault()}
      >
        <div
          className="gridlines"
          style={{
            backgroundImage:
              "linear-gradient(var(--line) 1px, transparent 1px), linear-gradient(90deg, var(--line) 1px, transparent 1px)",
            backgroundSize: `${cell}px ${cell}px`,
          }}
        />
        {optimizedGridRender}
      </div>

      <div className="powerup-tray">
        {Object.entries(POWERUP_DEFINITIONS).map(([key, def]) => (
          <button
            key={key}
            className={`powerup-btn ${activePowerup === key ? 'active' : ''}`}
            onClick={() => handlePowerupSelect(key)}
            draggable={powerups[key] > 0 && key !== 'shuffle'}
            onDragStart={(e) => handlePowerupDragStart(e, key, def.icon)}
            onDragEnd={handlePowerupDragEnd}
            disabled={!powerups[key] || powerups[key] <= 0}
            title={`${def.name} (Owned: ${powerups[key] || 0})`}
          >
            <div className="powerup-icon">{def.icon}</div>
            <div className="powerup-quantity">{powerups[key] || 0}</div>
          </button>
        ))}
      </div>

      <div className="row" style={{ gap: 8, marginTop: 12 }}>
        <button className="btn" onClick={() => doHint()} disabled={timeLeft <= 0}>
          ðŸ’¡ Hint
        </button>
        <button className="btn" onClick={() => shuffleBoard()} disabled={timeLeft <= 0}>
          ðŸ”€ Shuffle
        </button>
        <button className="btn" onClick={() => resetGame()}>
          â™»ï¸ Reset
        </button>
        <button
          className="btn"
          onClick={() => setPaused((p) => !p)}
        >
          {paused ? "â–¶ï¸ Resume" : "â¸ Pause"}
        </button>
      </div>

      <div
        className="progress rush-progress"
        style={{
          width: `${(timeLeft / GAME_DURATION) * 100}%`,
          height: 8,
          background: `linear-gradient(90deg, ${getTimerColor()}, ${getTimerColor()}80)`,
          borderRadius: 6,
          marginTop: 10,
          boxShadow: `0 0 8px ${getTimerColor()}40`
        }}
      />
    </div>
  );
}

// ====== Helper Functions (Updated for Phase 2) ======

function initSolvableGrid() {
  const g = Array.from({ length: ROWS }, () =>
    Array.from({ length: COLS }, () => randCat())
  );
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (c >= 2 && g[r][c] === g[r][c - 1] && g[r][c] === g[r][c - 2]) {
        g[r][c] = pickDifferent(g[r][c]);
      }
      if (r >= 2 && g[r][c] === g[r - 1][c] && g[r][c] === g[r - 2][c]) {
        g[r][c] = pickDifferent(g[r][c]);
      }
    }
  }
  if (!hasAnyMove(g)) return shuffleToSolvable(g);
  return g;
}

function pickDifferent(curr) {
  const choices = CAT_SET.filter((x) => x !== curr);
  return choices[(Math.random() * choices.length) | 0];
}

function cloneGrid(g) {
  return g.map((row) => row.slice());
}

function inBounds(r, c) {
  return r >= 0 && c >= 0 && r < ROWS && c < COLS;
}

function findMatches(g) {
  const matches = [];

  for (let r = 0; r < ROWS; r++) {
    let streak = 1;
    for (let c = 1; c < COLS; c++) {
      if (g[r][c] && g[r][c] === g[r][c - 1]) streak++;
      else {
        if (streak >= 3) {
          for (let k = 0; k < streak; k++) matches.push([r, c - 1 - k]);
        }
        streak = 1;
      }
    }
    if (streak >= 3) for (let k = 0; k < streak; k++) matches.push([r, COLS - 1 - k]);
  }

  for (let c = 0; c < COLS; c++) {
    let streak = 1;
    for (let r = 1; r < ROWS; r++) {
      if (g[r][c] && g[r][c] === g[r - 1][c]) streak++;
      else {
        if (streak >= 3) {
          for (let k = 0; k < streak; k++) matches.push([r - 1 - k, c]);
        }
        streak = 1;
      }
    }
    if (streak >= 3) for (let k = 0; k < streak; k++) matches.push([ROWS - 1 - k, c]);
  }

  return matches;
}

// ðŸ†• PHASE 2: Enhanced gravity that handles special grid
function applyGravity(g, sg) {
  for (let c = 0; c < COLS; c++) {
    for (let r = ROWS - 1; r >= 0; r--) {
      if (g[r][c] === null) {
        for (let rr = r - 1; rr >= 0; rr--) {
          if (g[rr][c] != null) {
            g[r][c] = g[rr][c];
            g[rr][c] = null;
            // Move specials too
            if (sg) {
              sg[r][c] = sg[rr][c];
              sg[rr][c] = null;
            }
            break;
          }
        }
      }
    }
  }
}

function refill(g) {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (g[r][c] === null) g[r][c] = randCat();
    }
  }
}

function hasAnyMove(g) {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const dirs = [
        [0, 1],
        [1, 0],
      ];
      for (const [dr, dc] of dirs) {
        const r2 = r + dr;
        const c2 = c + dc;
        if (!inBounds(r2, c2)) continue;
        const ng = cloneGrid(g);
        [ng[r][c], ng[r2][c2]] = [ng[r2][c2], ng[r][c]];
        const m = findMatches(ng);
        if (m.length > 0) return true;
      }
    }
  }
  return false;
}

function shuffleToSolvable(g) {
  let attempts = 0;
  while (attempts++ < 200) {
    const flat = g.flat();
    for (let i = flat.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [flat[i], flat[j]] = [flat[j], flat[i]];
    }
    const ng = [];
    for (let r = 0; r < ROWS; r++) {
      ng.push(flat.slice(r * COLS, r * COLS + COLS));
    }
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (c >= 2 && ng[r][c] === ng[r][c - 1] && ng[r][c] === ng[r][c - 2]) {
          ng[r][c] = pickDifferent(ng[r][c]);
        }
        if (r >= 2 && ng[r][c] === ng[r - 1][c] && ng[r][c] === ng[r - 2][c]) {
          ng[r][c] = pickDifferent(ng[r][c]);
        }
      }
    }
    if (hasAnyMove(ng)) return ng;
  }
  return g;
}

function findFirstMove(g) {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const dirs = [
        [0, 1],
        [1, 0],
      ];
      for (const [dr, dc] of dirs) {
        const r2 = r + dr;
        const c2 = c + dc;
        if (!inBounds(r2, c2)) continue;
        const ng = cloneGrid(g);
        [ng[r][c], ng[r2][c2]] = [ng[r2][c2], ng[r][c]];
        const m = findMatches(ng);
        if (m.length > 0) return [[r, c], [r2, c2]];
      }
    }
  }
  return null;
}
  
